{
  "hash": "f94c9a8a5eb328a96b0332891bb03d8e",
  "result": {
    "markdown": "---\ntitle: \"Data Exercise\" \noutput: html\neditor: visual\n---\n\n\n# About the dataset\n\nThe data is obtained from The University of Michigan Health and Retirement Study (HRS). HRS is a longitudinal panel study that surveys a representative sample of approximately 20,000 people in America, supported by the National Institute on Aging (NIA U01AG009740) and the Social Security Administration.\n\nThrough its unique and in-depth interviews, the HRS provides an invaluable and growing body of multidisciplinary data that researchers can use to address important questions about the challenges and opportunities of aging.\n\nPlease visit: https://hrsdata.isr.umich.edu/data-products/public-survey-data?\\_gl=1*8ofhfg*\\_ga*MTc5MDM4ODE3NS4xNzM4MzU5MjU5*\\_ga_FF28MW3MW2\\*MTczODM1OTI1OS4xLjEuMTczODM1OTI3NC4wLjAuMA..\n\nThe data is in STATA format.\n\nI plan to conduct survival analysis for retired people who had high Cholesterol in 2014 until they Heart Attack.\n\n# Install all packages needed\n\nInstall and library all packages needed in this section.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe following package(s) will be installed:\n- tidyverse [2.0.0]\nThese packages will be installed into \"~/MADA_NEW/muhammadnasir-mada2025-portofolio/renv/library/windows/R-4.4/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing tidyverse ...                      OK [linked from cache]\nSuccessfully installed 1 package in 26 milliseconds.\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\ninstall.packages(\"ggplot2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe following package(s) will be installed:\n- ggplot2 [3.5.1]\nThese packages will be installed into \"~/MADA_NEW/muhammadnasir-mada2025-portofolio/renv/library/windows/R-4.4/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing ggplot2 ...                        OK [linked from cache]\nSuccessfully installed 1 package in 25 milliseconds.\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(here)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at C:/Users/mn27712/MADA_NEW/muhammadnasir-mada2025-portofolio\n```\n:::\n\n```{.r .cell-code}\ninstall.packages(\"patchwork\")  # This package is to redefine \"/\" operator for plot arrangement\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe following package(s) will be installed:\n- patchwork [1.3.0]\nThese packages will be installed into \"~/MADA_NEW/muhammadnasir-mada2025-portofolio/renv/library/windows/R-4.4/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing patchwork ...                      OK [linked from cache]\nSuccessfully installed 1 package in 24 milliseconds.\n```\n:::\n\n```{.r .cell-code}\nlibrary(patchwork)\ninstall.packages(\"writexl\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe following package(s) will be installed:\n- writexl [1.5.2]\nThese packages will be installed into \"~/MADA_NEW/muhammadnasir-mada2025-portofolio/renv/library/windows/R-4.4/x86_64-w64-mingw32\".\n\n# Installing packages --------------------------------------------------------\n- Installing writexl ...                        OK [linked from cache]\nSuccessfully installed 1 package in 24 milliseconds.\n```\n:::\n\n```{.r .cell-code}\nlibrary(writexl)\nlibrary(haven)\n```\n:::\n\n\n# Loading Dataset\n\nThis dataset is longitudinal survey. In this analisys, I take three years, 2014, 2016,and 2018. I will read data per year then combine them.\n\nIn this part, I will load the dataset using here() function.\n\nReading data for 2014 and 2016 needs several steps, because the data is in STATA format, and also we need to match with dictionary. \\### Data for 2014\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## set path  dictionary \ndict.file2014 <- here::here(\"data-exercise\",\"data\", \"H14C_R.dct\")\n\nfile.exists(here::here(\"data-exercise\", \"data\", \"H14C_R.dct\")) # If we want to check the working path \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Read the dictionary file \ndf.dict2014 <- read.table(dict.file2014, skip = 1, fill = TRUE, stringsAsFactors = FALSE)\n\n# Set column names for dictionary dataframe \ncolnames(df.dict2014) <- c(\"col.num\",\"col.type\",\"col.name\",\"col.width\",\"col.lbl\")\n\n# Remove last row which only contains a closing }\ndf.dict2014 <- df.dict2014[-nrow(df.dict2014),]\n\n\n# Remove first row \ndf.dict2014 <- df.dict2014[-1,]\n\n# Extract numeric value from column width field\ndf.dict2014$col.width <- as.integer(sapply(df.dict2014$col.width, gsub, pattern = \"[^0-9\\\\.]\", replacement = \"\"))\n\n\n# Convert column types to format to be used with read_fwf function\ndf.dict2014$col.type <- sapply(df.dict2014$col.type, function(x) ifelse(x %in% c(\"int\",\"byte\",\"long\"), \"i\", ifelse(x == \"float\", \"n\", ifelse(x == \"double\", \"d\", \"c\"))))\n\n\n\n##data file \ndata.file2014 <- here::here( \"data-exercise\",\"data\", \"H14C_R.da\") \n\n# Read the data file into a dataframe\ndf2014 <- read_fwf(\n    file = data.file2014,\n    fwf_widths(widths = df.dict2014$col.width, col_names = df.dict2014$col.name),\n    col_types = paste(df.dict2014$col.type, collapse = \"\"))\n\n# Add column labels to headers\n#attributes(df2014)$variable.labels <- df.dict2014$col.lbl\n\nhead(df2014)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 227\n  HHID   PN    OSUBHH NSUBHH OPN_SP  OCSR OFAMR OFINR OC231 OC234 OC235 OC239\n  <chr>  <chr> <chr>  <chr>  <chr>  <int> <int> <int> <int> <int> <int> <int>\n1 000003 020   0      0      <NA>       1     1     1     0     1     1     1\n2 010001 010   0      0      <NA>       1     1     1     0     1     1     1\n3 010003 030   0      0      <NA>       1     1     1     0     1     1     1\n4 010004 040   0      0      <NA>       1     1     1     0     1     1     1\n5 010013 040   1      1      <NA>       1     1     1     0     1     1     1\n6 010013 010   2      2      <NA>       1     1     1     0     1     1     1\n# ℹ 215 more variables: OC248 <int>, OC185 <int>, OC001 <int>, OC002 <int>,\n#   OC005 <int>, OC006 <int>, OC010 <int>, OC214 <int>, OC011 <int>,\n#   OC012 <int>, OC236 <int>, OC018 <int>, OC019 <int>, OC020 <int>,\n#   OC232u1 <int>, OC021M1 <int>, OC021M2 <int>, OC021M3 <int>, OC021M4 <int>,\n#   OC021M5 <int>, OC021M6 <int>, OC021M7 <int>, OC023 <int>, OC024 <int>,\n#   OC028 <int>, OC029 <int>, OC030 <int>, OC031 <int>, OC032 <int>,\n#   OC033 <int>, OC034 <int>, OC036 <int>, OC037 <int>, OC038 <int>, …\n```\n:::\n:::\n\n\n### Data for 2016\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## set path  dictionary \ndict.file2016 <- here::here(\"data-exercise\",\"data\", \"H16C_R.dct\")\n\nfile.exists(here::here(\"data-exercise\", \"data\", \"H16C_R.dct\")) # If we want to check the working path \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Read the dictionary file \ndf.dict2016 <- read.table(dict.file2016, skip = 1, fill = TRUE, stringsAsFactors = FALSE)\n\n# Set column names for dictionary dataframe \ncolnames(df.dict2016) <- c(\"col.num\",\"col.type\",\"col.name\",\"col.width\",\"col.lbl\")\n\n# Remove last row which only contains a closing }\ndf.dict2016 <- df.dict2016[-nrow(df.dict2016),]\n\n\n# Remove first row \ndf.dict2016 <- df.dict2016[-1,]\n\n# Extract numeric value from column width field\ndf.dict2016$col.width <- as.integer(sapply(df.dict2016$col.width, gsub, pattern = \"[^0-9\\\\.]\", replacement = \"\"))\n\n\n# Convert column types to format to be used with read_fwf function\ndf.dict2016$col.type <- sapply(df.dict2016$col.type, function(x) ifelse(x %in% c(\"int\",\"byte\",\"long\"), \"i\", ifelse(x == \"float\", \"n\", ifelse(x == \"double\", \"d\", \"c\"))))\n\n\n\n##data file \ndata.file2016 <- here::here( \"data-exercise\",\"data\", \"H14C_R.da\") \n\n# Read the data file into a dataframe\ndf2016 <- read_fwf(\n    file = data.file2016,\n    fwf_widths(widths = df.dict2016$col.width, col_names = df.dict2016$col.name),\n    col_types = paste(df.dict2016$col.type, collapse = \"\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n```\n:::\n\n```{.r .cell-code}\n# Add column labels to headers\n#attributes(df2016)$variable.labels <- df.dict2016$col.lbl \nhead(df2016)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 240\n  HHID   PN    PSUBHH OSUBHH PPN_SP  PCSR PFAMR PFINR PC231 PC234 PC235 PC239\n  <chr>  <chr> <chr>  <chr>  <chr>  <int> <int> <int> <int> <int> <int> <int>\n1 000003 020   0      0      <NA>       1     1     1     0     1     1     1\n2 010001 010   0      0      <NA>       1     1     1     0     1     1     1\n3 010003 030   0      0      <NA>       1     1     1     0     1     1     1\n4 010004 040   0      0      <NA>       1     1     1     0     1     1     1\n5 010013 040   1      1      <NA>       1     1     1     0     1     1     1\n6 010013 010   2      2      <NA>       1     1     1     0     1     1     1\n# ℹ 228 more variables: PC248 <int>, PC001 <int>, PC185 <int>, PC002 <int>,\n#   PC005 <int>, PC006 <int>, PC010 <int>, PC285 <int>, PC214 <int>,\n#   PC011 <int>, PC012 <int>, PC236 <int>, PC018 <int>, PC019 <int>,\n#   PC020 <int>, PC232u1 <int>, PC021M1 <int>, PC021M2 <int>, PC021M3 <int>,\n#   PC021M4 <int>, PC021M5 <int>, PC021M6 <int>, PC021M7 <int>, PC023 <int>,\n#   PC024 <int>, PC028 <int>, PC029 <int>, PC030 <int>, PC031 <int>,\n#   PC032 <int>, PC033 <int>, PC034 <int>, PC036 <int>, PC037 <int>, …\n```\n:::\n:::\n\n\n### Data for 2018\n\nData for 2018 is simple to read because it has R data format. It does not need many steps needed as data for 2014 and 2016.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2018 <- here::here(\"data-exercise\",\"data\", \"2018_h18c_r.dta\")\ndf2018 <- read_dta(df2018)\nhead(df2018)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 258\n  hhid   pn    qsubhh psubhh QPN_SP  qcsr qfamr qfinr QC231 QC234 QC235 QC239\n  <chr>  <chr> <chr>  <chr>  <chr>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 010003 030   0      0      \"\"         1     1     1     0     1     0     1\n2 010004 040   0      0      \"041\"      1     1     1     0     1     0     1\n3 010013 040   1      1      \"\"         1     1     1     0     1     0     1\n4 010038 010   0      0      \"040\"      5     5     1     0     1     0     1\n5 010038 040   0      0      \"010\"      1     1     5     0     1     0     1\n6 010059 020   0      0      \"030\"      1     1     5     0     1     0     1\n# ℹ 246 more variables: QC248 <dbl>, QC185 <dbl>, QC001 <dbl>, QC002 <dbl>,\n#   QC005 <dbl>, QC006 <dbl>, QC010 <dbl>, QC285 <dbl>, QC011 <dbl>,\n#   QC012 <dbl>, QC236 <dbl>, QC214 <dbl>, QC018 <dbl>, QC019 <dbl>,\n#   QC020 <dbl>, QC232U1 <dbl>, QC021M1 <dbl>, QC021M2 <dbl>, QC021M3 <dbl>,\n#   QC021M4 <dbl>, QC021M5 <dbl>, QC021M6 <dbl>, QC021M7 <dbl>, QC023 <dbl>,\n#   QC024 <dbl>, QC028 <dbl>, QC029 <dbl>, QC030 <dbl>, QC031 <dbl>,\n#   QC032 <dbl>, QC033 <dbl>, QC034 <dbl>, QC036 <dbl>, QC037 <dbl>, …\n```\n:::\n:::\n\n\n### Data for 2020\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2020 <- here::here(\"data-exercise\",\"data\", \"2020_H20C_R.dta\")\ndf2020 <- read_dta(df2020)\nhead(df2020)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 255\n  HHID   PN    RSUBHH QSUBHH RPN_SP  RCSR RFAMR RFINR RC231 RC234 RC235 RC239\n  <chr>  <chr> <chr>  <chr>  <chr>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 010003 030   0      0      \"\"         1     1     1     1     0     1     0\n2 010004 040   1      0      \"041\"      1     1     1     1     0     1     0\n3 010013 040   1      1      \"\"         1     1     1     1     0     1     0\n4 010038 010   0      0      \"040\"      1     5     1     1     0     1     0\n5 010038 040   0      0      \"010\"      5     1     5     1     0     1     0\n6 010050 010   0      0      \"\"         1     1     1     1     0     1     0\n# ℹ 243 more variables: RC248 <dbl>, RC185 <dbl>, RC001 <dbl>, RC002 <dbl>,\n#   RC005 <dbl>, RC006 <dbl>, RC010 <dbl>, RC285 <dbl>, RC011 <dbl>,\n#   RC012 <dbl>, RC236 <dbl>, RC214 <dbl>, RC018 <dbl>, RC019 <dbl>,\n#   RC020 <dbl>, RC021M1 <dbl>, RC021M2 <dbl>, RC021M3 <dbl>, RC021M4 <dbl>,\n#   RC021M5 <dbl>, RC023 <dbl>, RC024 <dbl>, RC028 <dbl>, RC029 <dbl>,\n#   RC030 <dbl>, RC031 <dbl>, RC032 <dbl>, RC033 <dbl>, RC034 <dbl>,\n#   RC036 <dbl>, RC037 <dbl>, RC038 <dbl>, RC039 <dbl>, RC257 <dbl>, …\n```\n:::\n:::\n\n\n### Data for 2022\n\nThe data is in STATA format\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## set path  dictionary \ndict.file2022 <- here::here(\"data-exercise\",\"data\", \"H22C_R.dct\")\n\nfile.exists(here::here(\"data-exercise\", \"data\", \"H22C_R.dct\")) # If we want to check the working path \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Read the dictionary file \ndf.dict2022 <- read.table(dict.file2022, skip = 1, fill = TRUE, stringsAsFactors = FALSE)\n\n# Set column names for dictionary dataframe \ncolnames(df.dict2022) <- c(\"col.num\",\"col.type\",\"col.name\",\"col.width\",\"col.lbl\")\n\n# Remove last row which only contains a closing }\ndf.dict2022 <- df.dict2022[-nrow(df.dict2022),]\n\n\n# Remove first row \ndf.dict2022 <- df.dict2022[-1,]\n\n# Extract numeric value from column width field\ndf.dict2022$col.width <- as.integer(sapply(df.dict2022$col.width, gsub, pattern = \"[^0-9\\\\.]\", replacement = \"\"))\n\n\n# Convert column types to format to be used with read_fwf function\ndf.dict2022$col.type <- sapply(df.dict2022$col.type, function(x) ifelse(x %in% c(\"int\",\"byte\",\"long\"), \"i\", ifelse(x == \"float\", \"n\", ifelse(x == \"double\", \"d\", \"c\"))))\n\n\n\n##data file \ndata.file2022 <- here::here( \"data-exercise\",\"data\", \"H22C_R.da\") \n\n# Read the data file into a dataframe\ndf2022 <- read_fwf(\n    file = data.file2022,\n    fwf_widths(widths = df.dict2022$col.width, col_names = df.dict2022$col.name),\n    col_types = paste(df.dict2022$col.type, collapse = \"\"))\n\n# Add column labels to headers\n#attributes(df2022)$variable.labels <- df.dict2022$col.lbl #\nhead(df2022)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 245\n  HHID   PN    SSUBHH RSUBHH SPN_SP  SCSR SFAMR SFINR SC231 SC234 SC235 SC239\n  <chr>  <chr> <chr>  <chr>  <chr>  <int> <int> <int> <int> <int> <int> <int>\n1 010001 010   0      0      <NA>       1     1     1     0     1     2     1\n2 010003 030   0      0      <NA>       1     1     1     0     1     2     1\n3 010004 040   1      1      <NA>       1     1     1     0     1     2     1\n4 010013 040   1      1      <NA>       1     1     1     0     1     2     1\n5 010038 010   0      0      040        1     5     1     0     1     2     1\n6 010038 040   0      0      010        5     1     5     0     1     2     1\n# ℹ 233 more variables: SC248 <int>, SC185 <int>, SC001 <int>, SC002 <int>,\n#   SC005 <int>, SC006 <int>, SC010 <int>, SC285 <int>, SC011 <int>,\n#   SC012 <int>, SC214 <int>, SC018 <int>, SC019 <int>, SC020 <int>,\n#   SC024 <int>, SC028 <int>, SC029 <int>, SC030 <int>, SC033 <int>,\n#   SC036 <int>, SC037 <int>, SC038 <int>, SC257 <int>, SC258 <int>,\n#   SC259 <int>, SC274 <int>, SC275 <int>, SC276 <int>, SC277 <int>,\n#   SC040 <int>, SC041 <int>, SC043 <int>, SC044 <int>, SC260 <int>, …\n```\n:::\n:::\n\n\n# Data Cleaning\n\n## Select variables needed for each year\n\nVariables that needed in this study include Household Identification number, Respondent Person Identification number, High Cholesterol Status, Years first had heart attack, Month first had heart attack, Ever had heart attack.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#data2014\nda2014 <- df2014 %>% \n  select(\"HHID\", \"PN\", \"OC283\", \"OC040\", \"OC258\", \"OC259\") %>%\n  rename(hhid = HHID, pn = PN, chol= OC283, ha = OC040, year = OC258, month= OC259)\n\n\nda2014 <- lapply(da2014, function(x) { attributes(x) <- NULL; x }) #delete the column lables from dataset, because their position is incorrect after deleting some variables. \nda2014 <- as.data.frame(da2014)  # Convert back to a dataframe\n\n#data2016\nda2016 <- df2016 %>% \n  select(\"HHID\", \"PN\", \"PC283\", \"PC040\", \"PC258\", \"PC259\") %>%\n  rename(hhid = HHID, pn = PN, chol= PC283, ha = PC040, year = PC258, month= PC259)\n\n\nda2016 <- lapply(da2016, function(x) { attributes(x) <- NULL; x }) #delete the column lables from dataset, because their position is incorrect after deleting some variables. \nda2016 <- as.data.frame(da2016)  # Convert back to a dataframe\n\n#data2018 \nda2018 <- df2018 %>%\n  select(\"hhid\", \"pn\", \"QC283\", \"QC040\", \"QC258\", \"QC259\") %>%\n  rename( chol = QC283, ha= QC040, year = QC258, month = QC259) # I rename the column names because in this year, they use different name. \n\nda2018 <- lapply(da2018, function(x) { attributes(x) <- NULL; x }) #delete the column lables from dataset, because their position is incorrect after deleting some variables. \nda2018 <- as.data.frame(da2018)  # Convert back to a dataframe\n\nda2020 <- df2020 %>%\n  select(\"HHID\", \"PN\", \"RC283\", \"RC040\", \"RC258\", \"RC259\") %>%\n  rename( hhid = HHID, pn = PN, chol = RC283, ha= RC040, year = RC258, month = RC259) # I rename the column names because in this year, they use different name. \n\nda2022 <- df2022 %>%\n  select(\"HHID\", \"PN\", \"SC283\", \"SC040\", \"SC258\", \"SC259\") %>%\n  rename( hhid = HHID, pn = PN, chol = SC283, ha= SC040, year = SC258, month = SC259) # I rename the column names because in this year, they use different name. \n```\n:::\n\n\n## Combine dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform a full join step-by-step\nmerged_data <- da2014 %>%\n  full_join(da2016, by = c(\"hhid\", \"pn\"), suffix = c(\"_2014\", \"_2016\")) %>%\n  full_join(da2018, by = c(\"hhid\", \"pn\"), suffix = c(\"\", \"_2018\")) %>%\n  full_join(da2020, by = c(\"hhid\", \"pn\"), suffix = c(\"\", \"_2020\")) %>%\n  full_join(da2022, by = c(\"hhid\", \"pn\"), suffix = c(\"\", \"_2022\")) \n\n# View result\nhead(merged_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    hhid  pn chol_2014 ha_2014 year_2014 month_2014 chol_2016 ha_2016 year_2016\n1 000003 020         5      NA        NA         NA        NA      NA        NA\n2 010001 010         1      NA        NA         NA        NA      NA        NA\n3 010003 030         1      NA        NA         NA        NA      NA        NA\n4 010004 040         5      NA        NA         NA        NA      NA        NA\n5 010013 040         1      NA        NA         NA        NA      NA        NA\n6 010013 010         1       5      1995         NA        NA      NA       995\n  month_2016 chol ha year month chol_2020 ha_2020 year_2020 month_2020\n1         NA   NA NA   NA    NA        NA      NA        NA         NA\n2         NA   NA NA   NA    NA        NA      NA        NA         NA\n3         NA    1 NA   NA    NA         1      NA        NA         NA\n4         NA    5 NA   NA    NA         1      NA        NA         NA\n5         NA    1 NA   NA    NA         1      NA        NA         NA\n6         NA   NA NA   NA    NA        NA      NA        NA         NA\n  chol_2022 ha_2022 year_2022 month_2022\n1        NA      NA        NA         NA\n2         5      NA        NA         NA\n3         5       5        NA         NA\n4         1      NA        NA         NA\n5         5      NA        NA         NA\n6        NA      NA        NA         NA\n```\n:::\n:::\n\n\nI realize that we only need cholesterol status in 2014, therefore, I want to delete cholesterol in 2016 and 2018\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- merged_data[, !(colnames(merged_data) %in% c(\"chol_2016\", \"chol\", \"chol_2020\", \"chol_2022\"))] %>% # deleting cholesterol from 2016 and 2018 \n  rename(ha_2018 = ha, year_2018 =year, month_2018 = month) # I rename variables from 2018 \n```\n:::\n\n\n# Exploratory data\n\nI want to create pie chat to show persons having high cholesterol in 2014.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable_1 <- table(df$chol_2014)\n\nchol_df <- as.data.frame(table_1) %>% \n  select(1,2)\n\ncolnames(chol_df) <- c(\"Chol_stat\", \"Count\") # rename the column \n\nchol_df  <- chol_df  %>%\n  filter(!Chol_stat %in% c(8, 9)) %>% \n  mutate(Chol_category = case_when(\n    Chol_stat == 1 ~ \"Normal\",  # If Chol_stat is 1, it's \"Normal\"\n    Chol_stat == 5 ~ \"High\",    # If Chol_stat is 5, it's \"High\"\n    TRUE ~ \"Other\"              # For any other value, label as \"Other\" (optional)\n  )) %>%\n  select(Chol_category, Count) %>%\n  rename(Chol_stat = Chol_category)\n  \n\nplot1 <- ggplot(chol_df, aes(x = \"\", y = Count, fill = Chol_stat)) + \n  geom_bar(stat = \"identity\", width = 1) +  # Create bar chart\n  coord_polar(theta = \"y\") +  # Convert to pie chart\n  geom_text(aes(label = paste0(round(Count / sum(Count) * 100, 1), \"%\")), \n            position = position_stack(vjust = 0.5), color = \"white\") +  # Add percentage labels\n  labs(title = \"Cholesterol status in 2014\") +\n  theme_void()\n\n\nfigure_file = here(\"data-exercise\",\"result\",\"figures\",\"chol_status.png\")\nggsave(filename = figure_file, plot=plot1) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSaving 7 x 5 in image\n```\n:::\n\n```{.r .cell-code}\nprint(plot1)\n```\n\n::: {.cell-output-display}\n![](data-exercise_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nI want to create plot number of person having Heart Attack in each year\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable_2 <- table(df$ha_2014)\ntable_3 <- table(df$ha_2016)\ntable_4 <- table(df$ha_2018)\ntable_5 <- table(df$ha_2020)\ntable_6 <- table(df$ha_2022)\n\n\n# Create the combined table\ntable_ha <- data.frame(\n  status = c(\"1\"),  # Heart attack status\n  `2014` = table_2[c(\"1\")],  # Heart attack status counts for 2014\n  `2016` = table_3[c(\"1\")],  # Heart attack status counts for 2016\n  `2018` = table_4[c(\"1\")],  # Heart attack status counts for 2018\n  `2020` = table_5[c(\"1\")],  # Heart attack status counts for 2020\n  `2022` = table_6[c(\"1\")]   # Heart attack status counts for 2022\n) %>%\n  rename(ha_2014 =X2014, ha_2016=X2016, ha_2018=X2018, ha_2020 =X2020, ha_2022 =X2022) %>%\n  mutate(ha_case = ifelse(status==1, \"heart attack\", \"No heart attack\")) %>%\n  select(ha_case, everything()) %>%  # Move ha_case to the first column\n  select(-status) %>%  # Remove the status column\n  select(-ha_case) # I delete it because it prevent to create long tabel \n\n# Create long table \ntable_ha <- table_ha %>%\n  pivot_longer(cols = starts_with(\"ha_\"),  # Reshape the ha_ columns into long format\n               names_to = \"year\",  # Column for years\n               values_to = \"count\") %>%\n  select(year, count)  \n\n# I want to change the value into numeric year\ntable_ha <- table_ha %>% \n  mutate(years = case_when(\n    year == \"ha_2014\" ~ \"2014\",\n    year == \"ha_2016\" ~ \"2016\",\n    year == \"ha_2018\" ~ \"2018\", \n    year == \"ha_2020\" ~ \"2020\",\n    year == \"ha_2022\" ~ \"2022\"\n  )) %>%\n  select(years, everything())\n\ntable_ha <- table_ha %>% \n  select(-year)\nhead(table_ha)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  years count\n  <chr> <int>\n1 2014    190\n2 2016    349\n3 2018    153\n4 2020    230\n5 2022    110\n```\n:::\n:::\n\n\nAfter creating long table, I want to create plot to show the number of heart attack cases each observation year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot2 <- ggplot(table_ha, aes(x = years, y = count)) +\n  geom_line(size = 1, color = \"blue\") +\n  geom_point(size = 3, color = \"red\") +\n  labs(title = \"Heart Attack Cases Over Time Among Retired People in the USA \", \n       x = \"Years\", \n       y = \"Number of Heart Attack Cases \",\n       caption= \"Sourse: Health and Retirement Study\") +\n  theme_minimal() + \n  theme_bw()+\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold.italic\")) + # to adjust the title position, size, and color\n   theme(plot.background = element_rect(color = \"black\", fill = NA, linewidth = 1)) # to create frame of the plot \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n```{.r .cell-code}\nfigure_file = here(\"data-exercise\",\"result\",\"figures\",\"heart attack cases.png\")\nggsave(filename = figure_file, plot=plot2) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSaving 7 x 5 in image\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\n```\n:::\n\n```{.r .cell-code}\nprint(plot2) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\n```\n:::\n\n::: {.cell-output-display}\n![](data-exercise_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nNow, I want to perform inclusion and inclusion criteria. I will include person who had high cholesterol level in 2014, but they did not have heart attack (disease free) in 2014.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Filter the dataset\n\ndf_filtered <- df %>%\n  filter(chol_2014 == 1, # High cholesterol in 2014\n         ha_2014 == 5) # No heart attack in 2014\ndata <- df_filtered\n```\n:::\n",
    "supporting": [
      "data-exercise_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}